"use strict";(self.webpackChunkredkubes_github_io=self.webpackChunkredkubes_github_io||[]).push([[2552],{984:(e,i,t)=>{t.r(i),t.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>p,frontMatter:()=>n,metadata:()=>r,toc:()=>c});var s=t(5893),o=t(1151);const n={slug:"gatekeeper",title:"Gatekeeper",sidebar_label:"Gatekeeper"},a=void 0,r={id:"apps/gatekeeper",title:"Gatekeeper",description:"Otomi offers Kubernetes security best practices through security constraints defined as OPA policies and enforced by Gatekeeper.",source:"@site/docs/apps/gatekeeper.md",sourceDirName:"apps",slug:"/apps/gatekeeper",permalink:"/docs/apps/gatekeeper",draft:!1,unlisted:!1,editUrl:"https://github.com/redkubes/redkubes.github.io/tree/main/docs/apps/gatekeeper.md",tags:[],version:"current",frontMatter:{slug:"gatekeeper",title:"Gatekeeper",sidebar_label:"Gatekeeper"},sidebar:"mainSidebar",previous:{title:"ExternalDNS",permalink:"/docs/apps/external-dns"},next:{title:"Gitea",permalink:"/docs/apps/gitea"}},l={},c=[{value:"Security in-depth",id:"security-in-depth",level:2},{value:"Statical analysis",id:"statical-analysis",level:2},{value:"Runtime protection",id:"runtime-protection",level:2},{value:"Modes",id:"modes",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Switching modes",id:"switching-modes",level:3},{value:"Using annotations to bypass policy checks",id:"using-annotations-to-bypass-policy-checks",level:3}];function d(e){const i={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",ol:"ol",p:"p",pre:"pre",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(i.p,{children:"Otomi offers Kubernetes security best practices through security constraints defined as OPA policies and enforced by Gatekeeper."}),"\n",(0,s.jsx)(i.h2,{id:"security-in-depth",children:"Security in-depth"}),"\n",(0,s.jsxs)(i.p,{children:["OPA policies are a replacement for the native PodSecurityPolicies and all defined policies are modeled after the most common psp setups. The Otomi values repository holds a ",(0,s.jsx)(i.code,{children:"policies.yaml"})," file with sane default presets. The full set of all policies can be found ",(0,s.jsx)(i.a,{href:"https://github.com/redkubes/otomi-core/tree/main/policies",children:"here"}),". Please see the ",(0,s.jsx)(i.a,{href:"https://github.com/open-policy-agent/gatekeeper-library",children:"OPA Gatekeeper policy library"})," as it is the source for the policy baseline here. We made a selection of usable policies for Otomi and adapted them to be used by Conftest as well for static analysis of manifests generated by Otomi. YAML Resources are verified against defined .rego policy rules, using the defined preset parameters as their constraint value."]}),"\n",(0,s.jsx)(i.h2,{id:"statical-analysis",children:"Statical analysis"}),"\n",(0,s.jsx)(i.p,{children:"Otomi's generated resources are statically evaluated by Conftest before deployment, but also at build time. This gives developers the tools to test their manifests locally, and increases certainty that only valid output will be generated."}),"\n",(0,s.jsx)(i.h2,{id:"runtime-protection",children:"Runtime protection"}),"\n",(0,s.jsx)(i.p,{children:"The same policies are upheld by OPA's Gatekeeper on the cluster during runtime, making sure all deployed resources are approved by it's admission hook."}),"\n",(0,s.jsx)(i.h2,{id:"modes",children:"Modes"}),"\n",(0,s.jsx)(i.p,{children:"Otomi supports 3 modes:"}),"\n",(0,s.jsxs)(i.ol,{children:["\n",(0,s.jsx)(i.li,{children:"Enforcing"}),"\n",(0,s.jsx)(i.li,{children:"Permissive (default)"}),"\n",(0,s.jsx)(i.li,{children:"Disabled"}),"\n"]}),"\n",(0,s.jsx)(i.p,{children:"In both Enforcing and Permissive mode, individual policies can be switched on or off. By default gatekeeper is enabled in permissive mode (logging & non-blocking)"}),"\n",(0,s.jsxs)(i.p,{children:["Customization of the policies is supported based on the Otomi ",(0,s.jsx)(i.a,{href:"https://github.com/redkubes/otomi-core/blob/main/values-schema.yaml",children:"schema"})," (or use Otomi Console). In case of specific requirements, admins can add their own custom policies."]}),"\n",(0,s.jsx)(i.h2,{id:"instructions",children:"Instructions"}),"\n",(0,s.jsx)(i.h3,{id:"switching-modes",children:"Switching modes"}),"\n",(0,s.jsxs)(i.p,{children:["Gatekeeper by default is disabled. To turn on Gatekeeper by dragging Gatekeeper from the disabled apps section (under Platform/Apps) to the enabled aps section and click on ",(0,s.jsx)(i.code,{children:"Deploy Changes"}),"."]}),"\n",(0,s.jsxs)(i.p,{children:["By default Gatekeeper now runs in Permissive mode (the ",(0,s.jsx)(i.code,{children:"Disable validating webhook"})," is active). To switch to blocking mode, uncheck the Disable validating webhook option:"]}),"\n",(0,s.jsx)(i.p,{children:(0,s.jsx)(i.img,{alt:"Gatekeeper modes",src:t(423).Z+"",width:"1962",height:"466"})}),"\n",(0,s.jsx)(i.h3,{id:"using-annotations-to-bypass-policy-checks",children:"Using annotations to bypass policy checks"}),"\n",(0,s.jsx)(i.p,{children:"It is possible to deviate from the baseline, provided there is a substantiated reason for doing so. To deviate from the baseline, annotations for the pod spec can be configured. Gatekeeper always keeps a log and thus it is traceable when an annotation is used. The use of annotations is a specific Otomi feature."}),"\n",(0,s.jsx)(i.p,{children:"In order to bypass the policy checks that are enforced by Gatekeeper, Otomi provides an override mechanism to disable or parameterize policy checks by means of annotations. This is based on a gentlemen's approach, and will be RBAC enforced in a future version of Otomi. The policy engine is aware of the following annotations for a pod spec:"}),"\n",(0,s.jsx)(i.pre,{children:(0,s.jsx)(i.code,{className:"language-yaml",children:'annotations:\n  policy.otomi.io/ignore: $policy[,$policy2] # pod level ignore for all containers\n  policy.otomi.io/ignore-sidecar: $policy[,$policy2] # pod level ignore for sidecars, such as istio-proxy\n  policy.otomi.io/ignore.$container: $policy[,$policy2] # ignore for just the mentioned container\n  policy.otomi.io/parameters.$policy: \'{"extra":"parameters"}\'\n'})}),"\n",(0,s.jsx)(i.p,{children:"Parameters will be merged with the default parameters passed to the rule (as defined in the policies.yaml file in the values repo). No override exists for a specific container to provide parameters for."})]})}function p(e={}){const{wrapper:i}={...(0,o.a)(),...e.components};return i?(0,s.jsx)(i,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},423:(e,i,t)=>{t.d(i,{Z:()=>s});const s=t.p+"assets/images/gatekeeper-modes-3978ccc93f80d9ca49cd7e832a5824f4.png"},1151:(e,i,t)=>{t.d(i,{Z:()=>r,a:()=>a});var s=t(7294);const o={},n=s.createContext(o);function a(e){const i=s.useContext(n);return s.useMemo((function(){return"function"==typeof e?e(i):{...i,...e}}),[i,e])}function r(e){let i;return i=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),s.createElement(n.Provider,{value:i},e.children)}}}]);