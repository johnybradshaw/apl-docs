"use strict";(self.webpackChunkredkubes_github_io=self.webpackChunkredkubes_github_io||[]).push([[4717],{3905:(e,t,r)=>{r.d(t,{Zo:()=>p,kt:()=>m});var n=r(7294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=n.createContext({}),u=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},p=function(e){var t=u(e.components);return n.createElement(l.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(r),m=a,h=d["".concat(l,".").concat(m)]||d[m]||c[m]||o;return r?n.createElement(h,i(i({ref:t},p),{},{components:r})):n.createElement(h,i({ref:t},p))}));function m(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var u=2;u<o;u++)i[u]=r[u];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},5684:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>u});var n=r(7462),a=(r(7294),r(3905));const o={slug:"harbor",title:"Harbor",sidebar_label:"Harbor"},i=void 0,s={unversionedId:"apps/harbor",id:"apps/harbor",title:"Harbor",description:"Introduction",source:"@site/docs/apps/harbor.md",sourceDirName:"apps",slug:"/apps/harbor",permalink:"/docs/apps/harbor",draft:!1,editUrl:"https://github.com/redkubes/redkubes.github.io/tree/main/docs/apps/harbor.md",tags:[],version:"current",frontMatter:{slug:"harbor",title:"Harbor",sidebar_label:"Harbor"},sidebar:"mainSidebar",previous:{title:"Grafana",permalink:"/docs/apps/grafana"},next:{title:"Ingress-nginx",permalink:"/docs/apps/ingress-nginx"}},l={},u=[{value:"Introduction",id:"introduction",level:2},{value:"Configuration",id:"configuration",level:2},{value:"Automation",id:"automation",level:2},{value:"Integrations",id:"integrations",level:2},{value:"Instructions",id:"instructions",level:2},{value:"Known issues",id:"known-issues",level:2},{value:"Docker login",id:"docker-login",level:3},{value:"OIDC: conflicting user",id:"oidc-conflicting-user",level:3},{value:"Pod multi-attach error",id:"pod-multi-attach-error",level:3}],p={toc:u};function c(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},p,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"introduction"},"Introduction"),(0,a.kt)("p",null,"Harbor is an open-source registry that secures artifacts with policies and role-based access control, ensures images are scanned and free from vulnerabilities, and signs images as trusted. As a ",(0,a.kt)("a",{parentName:"p",href:"https://www.cncf.io/announcements/2020/06/23/cloud-native-computing-foundation-announces-harbor-graduation/"},"CNCF")," graduated project, Harbor delivers compliance, performance, and interoperability to help you consistently and securely manage artifacts across cloud-native compute platforms like Kubernetes. (source: ",(0,a.kt)("a",{parentName:"p",href:"https://goharbor.io/"},"https://goharbor.io/"),")"),(0,a.kt)("h2",{id:"configuration"},"Configuration"),(0,a.kt)("h2",{id:"automation"},"Automation"),(0,a.kt)("p",null,"Otomi runs the following automation tasks:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Creating a project in Harbor for each team"),(0,a.kt)("li",{parentName:"ul"},"Creating a bot-account for each team"),(0,a.kt)("li",{parentName:"ul"},"Creating a Kubernetes pull secret in the team namespace to enable pulling of images out of the local registry"),(0,a.kt)("li",{parentName:"ul"},"Creating a Kubernetes push secret in the team namespace that can be downloaded (if enabled) by team members to push images to a private repo")),(0,a.kt)("h2",{id:"integrations"},"Integrations"),(0,a.kt)("p",null,"Harbor integrates with Keycloak for OIDC."),(0,a.kt)("h2",{id:"instructions"},"Instructions"),(0,a.kt)("h2",{id:"known-issues"},"Known issues"),(0,a.kt)("h3",{id:"docker-login"},"Docker login"),(0,a.kt)("p",null,"Unfortunately Harbor has not yet delivered a user friendly mechanism for users to interface with their registry via docker cli. To use docker cli one has to login with the registry EVERY time before using the cli. At the same time this fails when one is not logged into the Harbor dashboard beforehand. In order to login without issues one has to follow these steps:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"ONLY ONCE: get the cli secret from the Harbor dashboard (via User Profile)."),(0,a.kt)("li",{parentName:"ul"},"refresh Harbor dashboard web view (this will refresh the OIDC auth token)"),(0,a.kt)("li",{parentName:"ul"},"docker login using the cli secret as password: ",(0,a.kt)("inlineCode",{parentName:"li"},"docker login harbor.<cluster-domain> -u < User_Name > -p <CLI secret>")),(0,a.kt)("li",{parentName:"ul"},"do your docker pull/push etc within the token TTL window (60 secs)")),(0,a.kt)("p",null,"Usually this is not a problem as team users don't pull or push these images directly. We are working on solving this, and expect to have a fix soon."),(0,a.kt)("h3",{id:"oidc-conflicting-user"},"OIDC: conflicting user"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problem:")),(0,a.kt)("p",null,"Error while logging in to harbor with OIDC: ",(0,a.kt)("inlineCode",{parentName:"p"},"Conflict, the user with same username or email has been onboarded."),"."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Cause:")),(0,a.kt)("p",null,"By redeploing keycloak the same user gets a new ",(0,a.kt)("inlineCode",{parentName:"p"},"sub")," claim in ",(0,a.kt)("inlineCode",{parentName:"p"},"openid")," scope. Harbor uses ",(0,a.kt)("inlineCode",{parentName:"p"},"sub")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"iss")," claims in order to match them to a user from its database (see: ",(0,a.kt)("inlineCode",{parentName:"p"},"subiss")," column at ",(0,a.kt)("inlineCode",{parentName:"p"},"oidc_user")," table in ",(0,a.kt)("inlineCode",{parentName:"p"},"registry")," database). If the same user identifies with a new sub then harbor tries to create a new entry in the ",(0,a.kt)("inlineCode",{parentName:"p"},"harbor_user")," database table and it fails on the username column uniqueness constraint."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Solution:")),(0,a.kt)("p",null,"Please check up on this link when this problem occurs, because a fix might already be released: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/goharbor/harbor/issues/13674"},"goharbor/harbor#13674"),". If so, please create a PR to fix this in the ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/redkubes/otomi-core"},"otomi-core")," repo, or create an issue there. Otherwise continue:"),(0,a.kt)("p",null,"Connect to the database service"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"kh exec harbor-database-0 -it -- psql -U postgres\n")),(0,a.kt)("p",null,"Select the ",(0,a.kt)("inlineCode",{parentName:"p"},"registry")," database"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"\\c registry\n")),(0,a.kt)("p",null,"Find out the ",(0,a.kt)("inlineCode",{parentName:"p"},"<user_id>")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"SELECT user_id FROM harbor_user WHERE username = '<user name>';\n")),(0,a.kt)("p",null,"Remove the user from the database"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"DELETE FROM oidc_user WHERE user_id = <userid>;\nDELETE FROM harbor_user WHERE user_id = <userid>;\n")),(0,a.kt)("p",null,"Exit psql"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-sql"},"\\q\n")),(0,a.kt)("p",null,"Try to login once again and observe that you are asked to confirm your username."),(0,a.kt)("h3",{id:"pod-multi-attach-error"},"Pod multi-attach error"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Problem")),(0,a.kt)("p",null,"Kubernetes cannot schedule the ",(0,a.kt)("inlineCode",{parentName:"p"},"harbor-harbor-registry")," Pod."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Cause")),(0,a.kt)("p",null,"Multi-Attach error occurs for persistent volumes that support only one writer at a time."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Solution")),(0,a.kt)("p",null,"Delete an existing harbor registry replicaset. Note that this operation makes registry temporarely unavailable."))}c.isMDXComponent=!0}}]);